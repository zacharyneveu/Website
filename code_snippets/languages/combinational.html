<html>
<head>
<link rel="stylesheet" type="text/css" href="../../projectStyle.css">
<link href="https://fonts.googleapis.com/css?family=Rye|Ubuntu" rel="stylesheet">

<!-- Code highlighting options -->
<link rel="stylesheet" href="../../lib/code_highlight/styles/gruvbox-dark.css">
<script src="../../lib/code_highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<title>
	Combinational  Logic
</title>

</head>
<body>
	<div id="header">
		<center>
			<h1>
				Combinational  Logic
			</h1>
		</center>
	</div>

	<div id="container">
		<div id="lhs" class = "column">
			<div id="row1left" class="row">
				<h3> Three-Bit Adder </h3>
				This model is the design of a modular 3-bit adder.  The code is
				fairly simple, but is a good example of how structural
				implementations work.
				<pre>
					<code class="verilog">
module fullAdderDF(input A, input B, input Cin, output sum, output Cout);
	assign sum = (A^B)^(Cin);
	assign Cout = (A&B)|((Cin)&(A^B));
endmodule

module threebitadder(
	input [3:0] a,
	input [3:0] b,
	output [3:0] sum,
	output carry
);
	assign Cin = 1'b0;
	fullAdderDF s0(.A(a[0]), .B(b[0]), .Cin(Cin), .sum(sum[0]), .Cout(ripple0) );
	fullAdderDF s1(.A(a[1]), .B(b[1]), .Cin(ripple0), .sum(sum[1]), .Cout(ripple1) );
	fullAdderDF s2(.A(a[2]), .B(b[2]), .Cin(ripple1), .sum(sum[2]), .Cout(carry) );
endmodule
					</code>
				</pre>
			</div>

			<div id=row2left class="row">
				<h3> Magnitude Comparator </h3>
				This is the verilog code for a 4-bit magnitude comparator.
				This takes two 4-bit inputs and has 3 outputs: less than,
				greater than, and equal to.
				<pre>
					<code class="verilog">
module mag_comp(input[3:0]a, input[3:0]b, output eq, output lt, output gt);
	wire[3:0]x;
	assign x = (a~^b);
	assign eq = x[3] & x[2] & x[1] & x[0];
	assign lt = (~a[3]&b[3]) | (x[3]&~a[2]&~b[2]) | (x[2]&~a[1]&b[1]) | (x[1]&~a[0]&b[0];
	assign gt = ~(eq|lt);
endmodule
					</code>
				</pre>
			</div>
		</div>

		<div id="rhs" class = "column">
			<div id="row1right" class="row">
			<h3> ALU </h3>
			This is the code for a simple Arithmetic Logic Unit.  This ALU
				takes two eight-bit inputs and a three-bit control signal.  It
				outputs the result of the calculation, as well as two flags:
				overflow and take_branch.  The eight operations are: add,
				invert second input, and, or, arithmetic shift right, logical
				shift left, branch on equal, and branch on not equal.
				<pre>
					<code class="verilog">
module eighbit_alu(
	input[7:0]a,
   	input[7:0]b,
	input[2:0]s,
	output[7:0]f,
	output ovf,
	output take_branch);

    reg [7:0]f;
    reg ovf,take_branch;

    always@(*)
    begin
    ovf = 0;
	take_branch = 0;
	case(s)
		3'b000:
	   	begin
		   	f=a+b;
		   	ovf=(a[7]&b[7]&~f[7]) | (~a[7]&~b[7]&f[7]);
	   	end
	   	3'b001:f=~b;
	   	3'b010:f=a&b;
	   	3'b011:f=a|b;
	   	3'b100:
	   	begin
		   	if(a[7])
			   	f=(a>>1)|(8'b10000000);
		   	else
			   	f=a>>1;
	   	end
	   	3'b101:f=a&lt;&lt;1;
	   	3'b110:
	   	begin
		   	f=0;
		   	if(a==b)
			   	take_branch = 1;
	   	end
	   	3'b111:
	   	begin
		   	f=0;
		   	if(a!=b)
			   	take_branch = 1;
	   	end
	endcase
	end
endmodule

					</code>
				</pre>
			</div>

			<div id="row3right" class="row">
			</div>
		</div>
	</div>

</body>

</html>
